<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        let exp = '(exp1 and 表达式2) or (exp3 and exp4)';
        let exp2 = "(分类号=('B23B%' or 'B23C%' or 'B24B%' or 'B27C3/%' or 'B23F%' or 'B23H%') or 名称=(车床 or 铣床 or 钻床 or 镗床 or 磨床 or ((车削 or 车铣 or 车磨 or 车拉 or 铣削 or 车铣 or 磨削 or 珩磨 or 滚齿 or 插齿 or 车齿 or 刨齿 or 铣齿 or 拉齿 or 珩齿 or 剃齿 or 磨齿) and (机 or 设备 or 装置 or 工装 or 生产线 or 中心 or 系统))) or (摘要,主权项+=(车床 or 铣床 or ((车削 or 车铣 or 车磨 or 车拉 or 铣削 or 车铣) and (设备 or 装置 or 工装 or 生产线 or 中心))) and 分类号=('B23%')) or ((名称=(机床 or 加工中心)) and 名称,摘要,主权项+=((车削 not 车削膜) or 铣削)) or (名称,摘要,主权项+=(钻床 or 钻镗床 or 钻头) and 分类号=('B27C%')) or (名称,摘要,主权项+=(磨 and (床 or 设备 or 装置 or 工装)) and 分类号=('B23%')) or 申请（专利权）人=(格里森 or 赫思机器及工具 or 机床) or (摘要,主权项+=((滚齿 or 插齿 or 车齿 or 刨齿 or 铣齿 or 拉齿 or 珩齿 or 剃齿 or 磨齿) and (机 or 床 or 设备 or 装置 or 工装)) and 分类号=('B23%' or 'G%')) or (名称,摘要,主权项+=(线切割 or 走丝 or 电加工 or 电火花) and 分类号=('B23H%' or 'B23Q%' or '15-09%')) or (名称,摘要,主权项+=((线切割 or 电加工 or 电火花) and (导丝 or 丝架 or 线架 or 运丝 or 丝筒 or 走丝 or 电火花 or 钼丝 or 脉冲 or 电极丝 or 断线 or 断丝 or 电源)) and 分类号=('B01D%' or 'B23%' or 'G05%' or 'G06%' or 'H%')) or (分类号=('B26D7%') or 名称=(电加工 or 电火花 or 电腐蚀 or 电蚀 or 夹具))) and (分类号=('B23Q15%' or 'G05B19/18%' or 'G05B19/19%' or 'G05B19/2%' or 'G05B19/3%' or 'G05B19/40%' or 'G05B19/41%' or 'G05B13%') or 名称,摘要,主权项+=(数控 or 闭环控制 or 数值控制 or 数字控制 or NC or CNC or 插补 or 运动控制 or 自适应))"
        function TreeNode() {
            this.left = null;
            this.right = null;
            this.value = null;
        }

        function isLogicOpt(str, str1) {
            return str === 'and' ||
                str === 'or' ||
                str === 'not';
        }

        function getWords(exp) {
            exp = exp.replace(/\s+/ig, ' ');
            console.log('getWords --->', exp);
            let bracket = 0;
            let bracketStr = '';
            let quotation = false;
            let chars = [];
            let words = [];
            let word = '';
            for (let i = 0; i < exp.length; i++) {
                let char = exp[i];
                if (char === '(') {
                    bracketStr += char;
                    bracket++;
                }
                if (char === ')') {
                    bracketStr += char;
                    bracket--;
                }
                if (char === "'") {
                    quotation = true;
                    word += char;
                    i++;
                    for (; i < exp.length; i++) {
                        char = exp[i];
                        word += char;
                        if (char === "'") {
                            quotation = false;
                            break;
                        }
                    }
                    continue;
                }
                if (quotation) {
                    console.error('单引号不匹配--->', exp);
                    throw "单引号不匹配";
                }
                if (char === '\\') {
                    word += char;
                    i++;
                    char = exp[i];
                    word += char;
                    continue;
                }
                if (char === ' ' && bracket === 0) {
                    words.push(word);
                    word = '';
                    continue;
                }
                word += char;
            }
            if (word != '') {
                words.push(word);
            }
            if (bracket !== 0) {
                console.error('括号不匹配 ---->', exp, bracket, bracketStr);
                throw "括号不匹配";
            }
            return words;
        }

        function copy(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        function analysisExp(exp) {

            let words = getWords(exp);
            console.log(words);
            if (!words || words.length <= 1) {
                return null;
            }
            // root的right总是null
            let root = new TreeNode();
            root.value = { text: '()', type: 'root' }
            let length = words.length;
            for (let i = 0; i < length; i++) {
                let word = words[i];

                if (word[0] === '(' && word[word.length - 1] === ')') {
                    word = word.replace(/(^\(|\)$)/ig, '');
                }

                let child = analysisExp(word);
                if (child === null) {
                    // 说明就是一个表达式，这个表达式里面不含有表达式了
                    let leaf = new TreeNode();
                    if (isLogicOpt(word)) {
                        leaf.value = { text: word, type: 'opt' };
                        if (root.left === null) {
                            let errLeft = new TreeNode();
                            errLeft.value = { text: 'Left_error', type: '逻辑运算符左边没有表达式' }
                            leaf.left = copy(errLeft);
                            root.left = copy(leaf);
                        } else {
                            let preLeft = copy(root.left);
                            leaf.left = copy(preLeft);
                            root.left = copy(leaf);
                        }
                    } else {
                        if (root.left === null) {
                            leaf.value = { text: word, type: 'left' }
                            root.left = JSON.parse(JSON.stringify(leaf));
                        } else {
                            let preOpt = root.left;
                            if (preOpt.leaf === null) {
                                // 正常情况下左节点不可能为空
                                let errLeft = new TreeNode();
                                errLeft.value = { text: 'Left_error', type: '逻辑运算符左边没有表达式' }
                                preOpt.left = copy(errLeft);
                            }
                            if (preOpt.right !== null) {
                                // 如果右叶子不为空，则说明遇到了两个连续的表达式使用空格分隔的情况，这里补一个or运算符节点
                                let plusRoot = new TreeNode();
                                plusRoot.value = { text: '()', type: 'root' };
                                let preRight = copy(preOpt.right);
                                plusRoot.left = preRight;
                                leaf.value = { text: word, type: 'right' }
                                plusRoot.right = copy(leaf);
                                preOpt.right = plusRoot;
                            } else {
                                leaf.value = { text: word, type: 'right' }
                                preOpt.right = copy(leaf);
                            }
                        }
                    }
                } else {
                    // 说明底下是一个表达式，那么该word不可能是逻辑运算符
                    if (root.left === null) {
                        root.left = child;
                    } else {
                        let preOpt = root.left;
                        if (preOpt.leaf === null) {
                            // 正常情况下左节点不可能为空
                            let errLeft = new TreeNode();
                            errLeft.value = { text: 'Left_error', type: '逻辑运算符左边没有表达式' }
                            preOpt.left = copy(errLeft);
                        }
                        if (preOpt.right === null) {
                            preOpt.right = child;
                        } else {
                            // 如果右叶子不为空，则说明遇到了两个连续的表达式使用空格分隔的情况，这里补一个or运算符节点
                            let plusRoot = new TreeNode();
                            plusRoot.value = { text: '()', type: 'root' };
                            let preRight = copy(preOpt.right);
                            plusRoot.left = preRight;
                            plusRoot.right = child;
                            preOpt.right = plusRoot;
                        }
                    }
                }
            }
            return root;
        }

        let simpleTree = analysisExp(exp);
        console.log('st --->', simpleTree);

        /**
         * 先序遍历
         */
        function dlr(tree, queue) {
            queue.push(tree.value.text);
            if (tree.left !== null) {
                dlr(tree.left, queue);
            }
            if (tree.right !== null) {
                dlr(tree.right, queue)
            }
        }

        function dlr(tree, queue) {
            queue.push(tree.value.text);
            if (tree.left !== null) {
                console.log('tree.left--->', tree.left.value);
                if (tree.left.value && tree.left.value.type === 'root') {
                    return tree.left;
                } else {
                    return dlr(tree.left, queue);
                }
            }
            if (tree.right !== null) {
                if (tree.right.value && tree.right.value.type === 'root') {
                    return tree.right;
                }
                return dlr(tree.right, queue)
            }
        }

        let queue = [];
        dlr(simpleTree, queue);
        console.log('queue', queue);


        function tree2List(tree) {
            if (tree === null) {
                return null;
            }
            let vt = {};
            vt = {
                id: tree.value.text,
                children: []
            }

            let left = copy(tree.left);
            let right = copy(tree.right);

            if (left === null && right === null) {
                return vt;
            }

            let queue = [];
            let next = dlr(tree, queue);
            for (let i = queue.length - 1; i >= 0; i--) {
                vt.children.push({ id: queue[i] });
            }

            if (next != null) {
                let children = tree2List(next);
                vt.children.push(children);
            }
            return vt;
        }

        console.log(tree2List(simpleTree));
    </script>
</body>

</html>
